import React, { createContext, useContext, useState, useEffect, ReactNode, useCallback } from 'react';
import { User, LoginCredentials } from '../types/user';
import * as authService from '../services/auth.service';
import { supabase } from '../services/supabase';
import { clearAllFilterPreferences } from '../../../shared/hooks/useLocalStorageFilters';
import { refreshCSRFToken, clearCSRFToken } from '../../../shared/utils/csrf';

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isGuest: boolean;
  isLoading: boolean;
  loading: boolean; // Alias for compatibility
  login: (credentials: LoginCredentials) => Promise<void>;
  register: (data: import('../types/user').RegisterData) => Promise<void>;
  logout: () => Promise<void>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Token storage keys
const TOKEN_KEY = 'authToken';
const REFRESH_TOKEN_KEY = 'refreshToken';
const USER_DATA_KEY = 'userData'; // Store user data including role

// Flag to prevent race conditions
let isFetchingProfile = false;

export const AuthProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  /**
   * Fetch user profile from Supabase with race condition prevention
   */
  const fetchUserProfile = useCallback(async (): Promise<User | null> => {
    // Prevent multiple simultaneous fetches
    if (isFetchingProfile) {
      console.log('Profile fetch already in progress, skipping...');
      return null;
    }

    isFetchingProfile = true;
    
    try {
      const userData = await authService.getCurrentUser();
      
      if (userData) {
        // Store user data in localStorage for persistence
        localStorage.setItem(USER_DATA_KEY, JSON.stringify(userData));
      }
      
      return userData;
    } catch (error) {
      console.error('Failed to fetch user profile:', error);
      
      // Try to get cached user data from localStorage
      const cachedUserData = localStorage.getItem(USER_DATA_KEY);
      if (cachedUserData) {
        console.log('Using cached user data due to fetch error');
        return JSON.parse(cachedUserData);
      }
      
      return null;
    } finally {
      isFetchingProfile = false;
    }
  }, []);

  /**
   * Initialize auth state on mount
   * Check for stored token and validate by fetching user data
   * Also listen for Supabase auth state changes
   */
  useEffect(() => {
    const initializeAuth = async () => {
      console.log('ðŸ”„ AuthContext: Starting initialization...');
      const token = localStorage.getItem(TOKEN_KEY);
      
      if (token) {
        try {
          // First, try to load cached user data immediately
          const cachedUserData = localStorage.getItem(USER_DATA_KEY);
          if (cachedUserData) {
            const parsedUserData = JSON.parse(cachedUserData);
            setUser(parsedUserData);
            console.log('âœ… Loaded cached user data:', parsedUserData);
          }
          
          // Add timeout to prevent hanging
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Auth initialization timeout')), 5000)
          );
          
          // Then validate token by fetching fresh user data in background with timeout
          const userData = await Promise.race([
            fetchUserProfile(),
            timeoutPromise
          ]).catch(err => {
            console.warn('âš ï¸ Failed to fetch fresh user data:', err.message);
            return null;
          }) as User | null;
          
          if (userData) {
            setUser(userData);
            console.log('âœ… Updated with fresh user data:', userData);
          } else if (!cachedUserData) {
            // Only clear tokens if we have no cached data and fetch failed
            console.log('âš ï¸ No user data available, clearing tokens');
            localStorage.removeItem(TOKEN_KEY);
            localStorage.removeItem(REFRESH_TOKEN_KEY);
            localStorage.removeItem(USER_DATA_KEY);
          }
        } catch (error) {
          console.error('âŒ Auth initialization failed:', error);
          
          // Try to use cached data even on error
          const cachedUserData = localStorage.getItem(USER_DATA_KEY);
          if (cachedUserData) {
            setUser(JSON.parse(cachedUserData));
            console.log('âœ… Using cached user data after initialization error');
          } else {
            // Only clear if no cached data available
            localStorage.removeItem(TOKEN_KEY);
            localStorage.removeItem(REFRESH_TOKEN_KEY);
            localStorage.removeItem(USER_DATA_KEY);
          }
        }
      } else {
        console.log('â„¹ï¸ No token found, user not authenticated');
      }
      
      console.log('âœ… AuthContext: Initialization complete, setting isLoading = false');
      setIsLoading(false);
    };

    initializeAuth();

    // Listen for Supabase auth state changes
    const { data: authListener } = supabase.auth.onAuthStateChange(async (event, session) => {
      console.log('ðŸ”„ Auth state changed:', event);
      
      if (event === 'SIGNED_OUT') {
        // Clear all auth data on sign out
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(REFRESH_TOKEN_KEY);
        localStorage.removeItem(USER_DATA_KEY);
        clearCSRFToken();
        clearAllFilterPreferences();
        setUser(null);
      } else if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
        // Update tokens and fetch user data
        if (session?.access_token) {
          localStorage.setItem(TOKEN_KEY, session.access_token);
          if (session.refresh_token) {
            localStorage.setItem(REFRESH_TOKEN_KEY, session.refresh_token);
          }
          
          // Fetch fresh user data
          const userData = await fetchUserProfile();
          if (userData) {
            setUser(userData);
          }
        }
      }
    });

    return () => {
      authListener.subscription.unsubscribe();
    };
  }, [fetchUserProfile]);

  /**
   * Login user with credentials using Supabase Auth
   */
  const login = async (credentials: LoginCredentials): Promise<void> => {
    try {
      setIsLoading(true);
      
      const { token, refreshToken, user: userData } = await authService.login(credentials);

      // Store tokens
      localStorage.setItem(TOKEN_KEY, token);
      if (refreshToken) {
        localStorage.setItem(REFRESH_TOKEN_KEY, refreshToken);
      }

      // Store user data including role
      localStorage.setItem(USER_DATA_KEY, JSON.stringify(userData));

      // Generate new CSRF token for the session
      refreshCSRFToken();

      // Set user state
      setUser(userData);
      console.log('User logged in with role:', userData.role);
    } catch (error: any) {
      console.error('Login failed:', error);
      
      // Provide more specific error messages
      if (error.message?.includes('Invalid login credentials')) {
        throw new Error('Invalid email/username or password');
      } else if (error.message?.includes('Email not confirmed')) {
        throw new Error('Please verify your email before logging in');
      } else if (error.status === 429) {
        throw new Error('Too many login attempts. Please try again later.');
      } else {
        throw new Error(error.message || 'Login failed. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Register new user with Supabase Auth
   */
  const register = async (data: import('../types/user').RegisterData): Promise<void> => {
    try {
      setIsLoading(true);
      
      const userData = await authService.register(data);

      // Get session from Supabase after registration
      const { data: sessionData } = await supabase.auth.getSession();
      
      if (sessionData?.session) {
        // Store tokens
        localStorage.setItem(TOKEN_KEY, sessionData.session.access_token);
        if (sessionData.session.refresh_token) {
          localStorage.setItem(REFRESH_TOKEN_KEY, sessionData.session.refresh_token);
        }
      }

      // Store user data including role
      localStorage.setItem(USER_DATA_KEY, JSON.stringify(userData));

      // Generate new CSRF token for the session
      refreshCSRFToken();

      // Set user state
      setUser(userData);
      console.log('User registered with role:', userData.role);
    } catch (error: any) {
      console.error('Registration failed:', error);
      
      // Provide more specific error messages
      if (error.message?.includes('already registered') || error.message?.includes('already exists')) {
        throw new Error('Email or username already exists');
      } else if (error.status === 429) {
        throw new Error('Too many registration attempts. Please try again later.');
      } else {
        throw new Error(error.message || 'Registration failed. Please try again.');
      }
    } finally {
      setIsLoading(false);
    }
  };

  /**
   * Logout user and clear tokens
   */
  const logout = useCallback(async () => {
    try {
      // Call Supabase logout
      await authService.logout();
    } catch (error) {
      console.error('Logout error:', error);
    }
    
    // Clear tokens from storage
    localStorage.removeItem(TOKEN_KEY);
    localStorage.removeItem(REFRESH_TOKEN_KEY);
    localStorage.removeItem(USER_DATA_KEY);
    
    // Clear CSRF token
    clearCSRFToken();
    
    // Clear filter preferences
    clearAllFilterPreferences();
    
    // Clear user state
    setUser(null);
    
    console.log('User logged out, all data cleared');
  }, []);

  /**
   * Update user profile
   */
  const updateProfile = async (data: Partial<User>): Promise<void> => {
    if (!user) {
      throw new Error('No user logged in');
    }
    
    try {
      // Update user profile in Supabase
      const { data: updatedData, error } = await supabase
        .from('users')
        .update({
          username: data.username,
          full_name: data.fullName,
          email: data.email,
          updated_at: new Date().toISOString(),
        })
        .eq('id', user.id)
        .select()
        .single();
      
      if (error) {
        throw error;
      }
      
      // Map to User type
      const updatedUser: User = {
        ...user,
        username: updatedData.username,
        email: updatedData.email,
        fullName: updatedData.full_name || updatedData.username,
        updatedAt: updatedData.updated_at,
      };
      
      // Update local user state and cache
      localStorage.setItem(USER_DATA_KEY, JSON.stringify(updatedUser));
      setUser(updatedUser);
      console.log('Profile updated:', updatedUser);
    } catch (error: any) {
      console.error('Update profile failed:', error);
      
      if (error.code === '23505') {
        throw new Error('Username or email already exists');
      } else {
        throw new Error(error.message || 'Failed to update profile. Please try again.');
      }
    }
  };

  /**
   * Refresh user data from server
   */
  const refreshUser = async (): Promise<void> => {
    try {
      const userData = await fetchUserProfile();
      if (userData) {
        setUser(userData);
        console.log('User data refreshed:', userData);
      } else {
        console.log('Failed to refresh user data, keeping current state');
      }
    } catch (error) {
      console.error('Failed to refresh user data:', error);
      // Keep current user state on error
    }
  };

  const value: AuthContextType = {
    user,
    isAuthenticated: !!user,
    isGuest: !user,
    isLoading,
    loading: isLoading, // Alias for compatibility with Legacy components
    login,
    register,
    logout,
    updateProfile,
    refreshUser
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

/**
 * Hook to access auth context
 * Must be used within AuthProvider
 */
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

/**
 * Get stored auth token
 */
export const getAuthToken = (): string | null => {
  return localStorage.getItem(TOKEN_KEY);
};

/**
 * Get stored refresh token
 */
export const getRefreshToken = (): string | null => {
  return localStorage.getItem(REFRESH_TOKEN_KEY);
};

/**
 * Set auth token
 */
export const setAuthToken = (token: string): void => {
  localStorage.setItem(TOKEN_KEY, token);
};

/**
 * Clear all auth tokens
 */
export const clearAuthTokens = (): void => {
  localStorage.removeItem(TOKEN_KEY);
  localStorage.removeItem(REFRESH_TOKEN_KEY);
  localStorage.removeItem(USER_DATA_KEY);
};

/**
 * Get cached user data
 */
export const getCachedUserData = (): User | null => {
  const cachedData = localStorage.getItem(USER_DATA_KEY);
  if (cachedData) {
    try {
      return JSON.parse(cachedData);
    } catch (error) {
      console.error('Failed to parse cached user data:', error);
      return null;
    }
  }
  return null;
};

export default AuthContext;
